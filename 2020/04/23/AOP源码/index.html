
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AOP源码 - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="AOP源码探究：一、@EnableAspectJAutoProxy是什么？
@Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoPro,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">AOP源码</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">AOP源码</h1>
        <div class="stuff">
            <span>四月 23, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Spring/" rel="tag">Spring</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="AOP源码探究："><a href="#AOP源码探究：" class="headerlink" title="AOP源码探究："></a>AOP源码探究：</h1><h3 id="一、-EnableAspectJAutoProxy是什么？"><a href="#一、-EnableAspectJAutoProxy是什么？" class="headerlink" title="一、@EnableAspectJAutoProxy是什么？"></a>一、<strong>@EnableAspectJAutoProxy</strong>是什么？</h3><ul>
<li><p><strong>@Import(AspectJAutoProxyRegistrar.class)</strong>：给容器中导入<strong>AspectJAutoProxyRegistrar</strong>，利用AspectJAutoProxyRegistrar自定义给容器中注册bean组件：</p>
<p><strong>internalAutoProxyCreator = AnnotationAwareAspectJAutoProxyCreator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">		AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</strong>对所必须的<strong>AspectJAnnotationAutoProxyCreator</strong>组件进行注册：</p>
<p>我们在源码中可以看见，这里注册的class为：<strong>AnnotationAwareAspectJAutoProxyCreator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator<span class="class">.<span class="keyword">class</span>, <span class="title">registry</span>, <span class="title">source</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>所以我们可以得到这个注解的作用是：给容器中注册一个<strong>AnnotationAwareAspectJAutoProxyCreator</strong>：自动代理创建器组件；</p>
</li>
</ul>
<hr>
<h3 id="二、AnnotationAwareAspectJAutoProxyCreator组件的结构："><a href="#二、AnnotationAwareAspectJAutoProxyCreator组件的结构：" class="headerlink" title="二、AnnotationAwareAspectJAutoProxyCreator组件的结构："></a>二、<strong>AnnotationAwareAspectJAutoProxyCreator</strong>组件的结构：</h3><ul>
<li><p>AnnotationAwareAspectJAutoProxyCreator</p>
<ul>
<li>父类：AspectJAwareAdvisorAutoProxyCreator<ul>
<li>父类：AbstractAdvisorAutoProxyCreator<ul>
<li>父类：AbstractAutoProxyCreator<ul>
<li>父类：ProxyProcessorSupport</li>
<li>接口：<strong>SmartInstantiationAwareBeanPostProcessor</strong>, <strong>BeanFactoryAware</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>我们关注的是：</p>
<p>​    1、后置处理器的工作 BeanPostProcessor：在bean初始化前后做的事情；</p>
<p>​    2、自动装配BeanFactory；</p>
<p>我们来找一下在这些<strong>子类</strong>和<strong>父类</strong>中有哪些与后置处理器和自动装配的方法：</p>
<p>1、<strong>AnnotationAwareAspectJAutoProxyCreator</strong>.initBeanFactory()</p>
<p>2、AspectJAwareAdvisorAutoProxyCreator没有</p>
<p>3、<strong>AbstractAdvisorAutoProxyCreator</strong>.setBeanFactory()，该函数还调用了：initBeanFactory</p>
<p>4、<strong>AbstractAutoProxyCreator</strong>.setBeanFactory()</p>
<p>5、<strong>AbstractAutoProxyCreator</strong>.postProcessBeforeInstantiation()</p>
<p>6、<strong>AbstractAutoProxyCreator</strong>.postProcessAfterInitialization()</p>
<p><img src="C:%5CUsers%5Couguangji%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200417163018114.png" alt="image-20200417163018114"></p>
</li>
</ul>
<hr>
<h3 id="三、流程：-定义–》注册–》创建–》赋值、初始化–》返回"><a href="#三、流程：-定义–》注册–》创建–》赋值、初始化–》返回" class="headerlink" title="三、流程： 定义–》注册–》创建–》赋值、初始化–》返回"></a>三、流程： 定义–》注册–》创建–》赋值、初始化–》返回</h3><ul>
<li><p><strong>1、创建IOC</strong>容器:<strong>ApplicationContext applicationContext=new AnnotationConfigApplicationContext(MainConfigOfAOP.class);</strong></p>
</li>
<li><p><strong>2、注册配置类，调用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    register(componentClasses);</span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先注册相关配置组件，然后刷新容器进行初始化。</p>
</li>
<li><p><strong>3、我们来看refresh()函数，看一下容器的刷新过程：</strong></p>
<ul>
<li><pre><code class="java"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span>
                postProcessBeanFactory(beanFactory);

                <span class="comment">// Invoke factory processors registered as beans in the context.</span>
                invokeBeanFactoryPostProcessors(beanFactory);

                <span class="comment">// Register bean processors that intercept bean creation.</span>
                registerBeanPostProcessors(beanFactory);

&lt;!--￼<span class="number">3</span>--&gt;</code></pre>
</li>
<li><p>2）、给容器中加别的BeanPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br></pre></td></tr></table></figure>

<p><img src="C:%5CUsers%5Couguangji%5CDesktop%5Cmarkdown%5CSpring%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%5Cimage%5Cimage1.jpg" alt="image-20200417164413329"></p>
<p>我们可以看到，我们所定义的AOP、internalAutoProxyCreator、ListenProcessor、还有我们自己加入到容器中的class：<strong>calculator</strong></p>
<p>然后通过遍历namelist加入到xxxPostProcessors中，根据不同的类型添加到不同的list中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        priorityOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3）、分别注册BeanPostProcessors根据不同的porcessor实现的接口的不同进行注册。</p>
<ul>
<li>首先注册的是：实现了 PriorityOrdered接口的processor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br></pre></td></tr></table></figure>

<ul>
<li>然后注册的是：实现了Ordered接口的processor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">		<span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br></pre></td></tr></table></figure>

<ul>
<li>最后注册没有实现接口的其他processor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">		<span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			<span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>可以发现每个注册前，都会对之排序，这个排序就控制了我们后面的链式执行的方法顺序。</p>
</li>
<li><p>4）、注册<strong>BeanPostProcessor</strong>，实际上就是创建BeanPostProcessor对象，保存在容器中。</p>
<ul>
<li><p>创建internalAutoProxyCreator的BeanPostProcessor是哪一种情况呢？</p>
<p>我们可以发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyProcessorSupport</span> <span class="keyword">extends</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Ordered</span></span></span><br></pre></td></tr></table></figure>

<p>在ProxyProcessorSupport这个父类中实现了Ordered的接口，所以该对象走的是第二种情况的register注册方式。</p>
</li>
<li><p>创建的过程：</p>
<p>1）、创建：bean实例</p>
<p>2）、 赋初值：populateBean(beanName, mbd, instanceWrapper);</p>
<p>3）、 初始化：exposedObject = initializeBean(beanName, exposedObject, mbd); </p>
<p><strong>初始化过程:</strong></p>
<p>​            1）、invokeAwareMethods()：处理Aware接口方法的回调</p>
<p>​            2）、<strong>applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName)：</strong></p>
<p>​                            初始化<strong>PostProcessorsBeforeInitialization</strong>后置处理器；</p>
<p>​            3）、<strong>invokeInitMethods(beanName, wrappedBean, mbd)：</strong></p>
<p>​                            执行<strong>自定义的</strong>初始化方法；</p>
<p>​            4）、<strong>applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName)：</strong></p>
<p>​                            初始化<strong>postProcessAfterInitialization</strong>后置处理器；</p>
<p>​            5）、调用setBeanFactory方法。</p>
<p>4）、BeanPostProcessor(<strong>AnnotationAwareAspectJAutoProxyCreator</strong>对象)</p>
<p>​        创建成功：—&gt;aspectJAdvisorsBuilder</p>
</li>
</ul>
</li>
<li><p>5）、把BeanPostProcessor注册到BeanFactory中：<strong>beanFactory.addBeanPostProcessor(postProcessor);</strong></p>
</li>
</ul>
<hr>
<p>​                            以上是创建+注册 <strong>AnnotationAwareAspectJAutoProxyCreator</strong> 的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAwareAspectJAutoProxyCreator &#x3D;&gt; 后置处理器是：InstantiationAwareBeanPostProcessor</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>5、创建的过程 详解：</strong></p>
<ul>
<li><p>1）、遍历获取容器中所有的Bean，然后依次创建对象：getBean(beanName)</p>
<p>​    getBean() –&gt;doGetBean()–&gt;<strong>getSingleton()</strong>【获取单实例bean，首先会判断容器中是否有这个bean，如果没有才创建，如果有就直接返回，不用重复创建】。</p>
</li>
<li><p>2）、创建bean:</p>
<p>​    【虽然获取到的beanName是interalAutoProxyCretor，但是在前面已经被赋值为</p>
<p>​      <strong>AnnotationAwareAspectJAutoProxyCreator</strong>对象，然后因为</p>
<p>​      <strong>AnnotationAwareAspectJAutoProxyCreator</strong>是<strong>InstantiationAwareBeanPostProcessor</strong>后置处理器，</p>
<p>​      所以它会尝试去返回，使用方法<strong>applyBeanPostProcessorsBeforeInstantiation</strong>】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br></pre></td></tr></table></figure>

<p>​    1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用；否则再创建，只要是创建好了的对象都会被缓存起来，所有的单实例只会有一个实例对象；但是注意：在如果发生了bean异常，会destroySingleton(beanName);销毁这个实例，下一次使用的时候需要再次创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object &#x3D; getCachedObjectForFactoryBean(beanName);</span><br></pre></td></tr></table></figure>

<p>​    2）、createBean()：创建bean：AnnotationAwareAspectJAutoProxyCreator会在任何bean创建之前先尝试返回的实例；</p>
<p><strong>注意：</strong></p>
<p>​        1、【BeanPostProcessor是在Bean对象创建完成初始化前后调用的】</p>
<p>​        2、【InstantiationAwareBeanPostProcessor是在任何创建Bean实例之前先尝试用后置处理器返回对象】</p>
<p>我们在前面已经讲到<strong>AnnotationAwareAspectJAutoProxyCreator</strong>是<strong>InstantiationAwareBeanPostProcessor</strong>后置处理器的接口实现的，所以在创建的bean实例的时候，先尝试使用后置处理器返回对象，如果从后置处理器无法返回对象，就进行创建这个对象。</p>
<p>​        3、Object beanInstance = doCreateBean(beanName, mbdToUse, args); 这才是真正的去创建一个bean实例，和之前的创建<strong>AnnotationAwareAspectJAutoProxyCreator</strong>过程是相同的。</p>
</li>
</ul>
<hr>
</li>
<li><p>6.</p>
<ul>
<li>1）、</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】的作用：</span><br><span class="line">* <span class="number">1</span>）、每一个bean创建之前，调用：postProcessBeforeInstantiation()：</span><br><span class="line">*      关心MathCalculator和LogAspect的创建：</span><br><span class="line">*      <span class="number">1</span>）、判断当前bean是否在adviseBeans(保存了所有需要增强&lt;切面&gt;的bean)中</span><br><span class="line">*      <span class="number">2</span>）、判断当前bean是否是基础类型【Advice、Pointcut、Advisor、AopInfrastructureBean】</span><br><span class="line">*      或者是否是切面（<span class="meta">@Aspect</span>）</span><br><span class="line">*      <span class="number">3</span>）、是否需要跳过：</span><br><span class="line">*              <span class="number">1</span>）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】</span><br><span class="line">*                  每一个封装的通知方法的增强器是InstantiationModelAwarePointcutAdvisor类型。</span><br><span class="line">*                  判断每一个增强器是否是AspectJPointcutAdvisor类型的：返回<span class="keyword">true</span></span><br><span class="line">*              <span class="number">2</span>）、永远返回<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2）、</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>）、创建对象【添加增强器，包装【通知方法】】</span><br><span class="line">* postProcessAfterInitialization：</span><br><span class="line">*      <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);包装操作，如果需要的话。</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">				<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">*      <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">*      <span class="number">1</span>）获取当前bean的所有增强器（通知方法）</span><br><span class="line">*          <span class="number">1</span>、找到候选的所有的增强器(找哪些通知方法是需要切入当前bean方法的)</span><br><span class="line">*          <span class="number">2</span>、获取到能在bean使用的增强器</span><br><span class="line">*          <span class="number">3</span>、给增强器进行排序：eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">*      <span class="number">2</span>）、获取到所有的增强器：Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">*      保存当前bean在advisedBeans中；</span><br><span class="line">*      <span class="number">3</span>）、如果当前bean需要增强，然后创建当前bean的代理对象</span><br><span class="line">*          <span class="number">1</span>）、获取所有的增强器(通知方法)</span><br><span class="line">*          <span class="number">2</span>）、保存到proxyFactory中</span><br><span class="line">*          <span class="number">3</span>）、创建代理对象：Spring自动觉得</span><br><span class="line">*              JdkDynamicAopProxy(config)；jdk动态代理</span><br><span class="line">*              ObjenesisCglibAopProxy(config)；cglib动态代理</span><br><span class="line">*      <span class="number">4</span>）、给容器中返回当前组件使用cglib增强了的代理对象</span><br><span class="line">*      <span class="number">5</span>）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<ul>
<li><p>7.全部的bean初始化创建完毕后，使用BeanPostProcessor进行包装，然后全部加入到对应的List中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br></pre></td></tr></table></figure>

<p>里面，然后再对List中的所有<strong>BeanPostProcessor</strong>进行排序和注册所有的BeanPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="四、目标方法的执行："><a href="#四、目标方法的执行：" class="headerlink" title="四、目标方法的执行："></a>四、目标方法的执行：</h3><ul>
<li>容器中保存了组件的代理对象(cglib增强后的对象)，这个对象里面保存了详细信息（比如增强器，目标对象）</li>
</ul>
<p>1）、单步调试进入执行目标方法，就来到了<strong>CglibAopProxy</strong>这个class，它的原理其实就是通过拦截器机制，来按照指定顺序来执行增加后的对象中的方法：</p>
<p>我们来看这个函数的源代码：</p>
<p>​    1）、使用<strong>intercept</strong>对目标方法的拦截</p>
<p>​    2）、根据<strong>ProxyFactory</strong>对象获取目标方法拦截器链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br></pre></td></tr></table></figure>

<p>​        1、首先进入这个函数，我们可以看到，首先判断在cache中是否存在这个链，如果存在就直接返回，如果不存在，则创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">		MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">		List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">		<span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">			cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">					<span class="keyword">this</span>, method, targetClass);</span><br><span class="line">			<span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cached;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​        2、进入创建函数：</p>
<p>​            1）、Advisor[] advisors = config.getAdvisors(); 获取到目标函数所拥有的所有拦截器：此处为5：一个默认的ExposeInvocationInterceptor和4个增强器</p>
<p>​            2）、<strong>List<Object> interceptorList = new ArrayList&lt;&gt;(advisors.length);</strong></p>
<p>​                新建一个拦截器链，来保存所有的方法拦截器：</p>
<p>​            3）、遍历所有的增强器，将其转化为<strong>MethodInterceptor</strong> ：</p>
<p>​                MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</p>
<p>​            4）、将增强器转为List<MethodInterceptor> interceptors：</p>
<p>​                如果是MethodInterceptor，直接加入到集合中；</p>
<p>​                如果不是：那么就使用AdvisorAdapter适配器将增强器转为-&gt;MethodInterceptor，转换完成就把数组返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">			<span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">			<span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">			<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">				interceptorList.add(<span class="keyword">new</span> 						 InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>​        3、返回拦截器链后会存入到Cache中，以便下次访问；        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">					<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">					<span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">					<span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">					<span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">					Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">					retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">					retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">				&#125;</span><br><span class="line">				retVal = processReturnType(proxy, target, method, retVal);</span><br></pre></td></tr></table></figure>

<p>​        4、如果没有拦截器链：直接执行目标方法：</p>
<p>​            拦截器链：每一个通知方法又被包装为方法拦截器，利用<strong>MethodInterceptor</strong>机制来达到先后执行顺序。</p>
<p>​        5、如果有拦截器链：</p>
<p>​            就把需要执行的目标对象，目标方法，拦截器链等信息传入创建一个<strong>CglibMethodInvocation</strong>对象，并调用CglibMethodInvocation.proceed()方法：</p>
<p>​            retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">			Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">			Object target = <span class="keyword">null</span>;</span><br><span class="line">			TargetSource targetSource = <span class="keyword">this</span>.advised.getTargetSource();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">					<span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">					oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">					setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...</span></span><br><span class="line">				target = targetSource.getTarget();</span><br><span class="line">				Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line">				List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">				Object retVal;</span><br><span class="line">				<span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">				<span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">				<span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">					<span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">					<span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">					<span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">					<span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">					Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">					retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// We need to create a method invocation...</span></span><br><span class="line">					retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">				&#125;</span><br><span class="line">				retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">				<span class="keyword">return</span> retVal;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">					targetSource.releaseTarget(target);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">					<span class="comment">// Restore old proxy.</span></span><br><span class="line">					AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Advised config, Method method, @Nullable Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// This is somewhat tricky... We have to process introductions first,</span></span><br><span class="line">		<span class="comment">// but we need to preserve order in the ultimate list.</span></span><br><span class="line">		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">		Advisor[] advisors = config.getAdvisors();</span><br><span class="line">		List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;&gt;(advisors.length);</span><br><span class="line">		Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">		Boolean hasIntroductions = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">			<span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">				<span class="comment">// Add it conditionally.</span></span><br><span class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">					<span class="keyword">boolean</span> match;</span><br><span class="line">					<span class="keyword">if</span> (mm <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">						<span class="keyword">if</span> (hasIntroductions == <span class="keyword">null</span>) &#123;</span><br><span class="line">							hasIntroductions = hasMatchingIntroductions(advisors, actualClass);</span><br><span class="line">						&#125;</span><br><span class="line">						match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						match = mm.matches(method, actualClass);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (match) &#123;</span><br><span class="line">						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">						<span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">							<span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">							<span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">							<span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">								interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">				<span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> interceptorList;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​        6、拦截器的触发过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// We start with an index of -1 and increment early.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object interceptorOrInterceptionAdvice =</span><br><span class="line">				<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">		<span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">			<span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">			<span class="comment">// been evaluated and found to match.</span></span><br><span class="line">			InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">			Class&lt;?&gt; targetClass = (<span class="keyword">this</span>.targetClass != <span class="keyword">null</span> ? <span class="keyword">this</span>.targetClass : <span class="keyword">this</span>.method.getDeclaringClass());</span><br><span class="line">			<span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">				<span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Dynamic matching failed.</span></span><br><span class="line">				<span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">				<span class="keyword">return</span> proceed();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">			<span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">			<span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>​            1）、如果没有拦截器执行目标方法，或者拦截器的索引等于拦截器数组大小-1(也就是最后一个拦截器)，就直接返回；</p>
<p>​            2）、如果拿到了拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object interceptorOrInterceptionAdvice =</span><br><span class="line">			<span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br></pre></td></tr></table></figure>

<p>​                每次使用拦截器索引拿到拦截器后，索引加一；</p>
<p>​                每次执行proceed，索引都会自增一次：</p>
<p>​                过程： 链式获取每一个拦截器，分别拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成                返回以后再来执行；使用拦截器机制，保证通知方法与目标方法的执行顺序；</p>
<hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>​    1）、@EnableAspectJAutoProxy开启AOP功能：@EnableAspectJAutoProxy会给容器中注册一个组件：AnnotationAwareAspectJAutoProxyCreator</p>
<p>​    2）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</p>
<p>​    3）、容器的创建流程：</p>
<p>​                    后置处理器的创建工作：</p>
<p>​                            1）、registerBeanPostProcessors(beanFactory);注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象</p>
<p>​                            2）、finishBeanFactoryInitialization(beanFactory); 初始化剩下的单实例bean</p>
<p>​                                    1、创建业务逻辑组件和切面组件；</p>
<p>​                                    2、AnnotationAwareAspectJAutoProxyCreator 拦截组件的创建过程</p>
<p>​                                    3、在创建完对象后，会判断组件是否需要增强：如果是：把切面的通知方法包装成增强器(Advisor),给业务逻辑组件创建一个代理对象(相当于增强后的包装组件)(cglib)</p>
<p>​    4）、执行目标方法：</p>
<p>​            代理对象执行目标的过程：</p>
<p>​                1）、CglibAopProxy.intercept();拦截目标方法的执行：</p>
<p>​                2）、利用拦截器的链式机制，依次进入每一个拦截器进行递归执行(先递归到最后一个拦截器，然后再回调执行方法)</p>
<p>​                3）、最后效果是：【<strong>顺序是通过拦截器链的方式来控制顺序</strong>】</p>
<p>​                    如果方法是正常执行：前置通知—&gt;目标方法—&gt;后置通知—&gt;返回通知</p>
<p>​                    如果方法出现异常：前置通知—&gt;目标方法—&gt;后置通知—&gt;异常通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这一段的AOP源码就介绍到这里了，因为自己的探究程度有限，希望大牛们多提出意见，大家一起更好的学习spring底层。</span><br></pre></td></tr></table></figure>










            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='http://link.hhtjim.com/163/425570952.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
